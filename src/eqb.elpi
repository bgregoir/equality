namespace eqb {

pred main i:inductive, i:string, o:list prop.
main I Prefix CL :- std.do! [
  coq.env.indt I _ _ N Arity _ _,
  do-params N Arity (global (indt I)) R,
  coq.say {coq.term->string R},
  std.assert-ok! (coq.typecheck R Rty) "eqb generates illtyped term",
  Name is Prefix ^ "eqb_fields",
  coq.env.add-const Name R Rty ff C,


  CL = [eqb-for _ (global (const C))], % TODO, quantify params
].

pred do-params i:int, i:term, i:term, o:term.
do-params J (prod _ T F) I {{ fun (p : lp:T) (eqp : p -> p -> bool) => lp:(R p eqp) }} :- J > 0, !, K is J - 1,
  @pi-decl `P` T p\
  @pi-decl `eqP` {{ lp:p -> lp:p -> bool }} eqP\
    eqb-for p eqP =>
    do-params K (F p) {coq.mk-app I [p]} (R p eqP).
do-params 0 _ Ind {{ fun (rec : lp:Ind -> lp:Ind -> bool) (x : positive) => lp:(R rec x) }} :-
  coq.safe-dest-app Ind (global (indt I)) Params,
  coq.env.indt I _ _ _ _ _ KT,
  std.map KT (coq.subst-prod Params) L,
  fields-for I F_t _ _ _,
  coq.mk-app (global (const F_t)) Params Fields_t,
  @pi-decl `rec` {{ lp:Ind -> lp:Ind -> bool }} rec\
  @pi-decl `x` {{ positive }} x\
  eqb-for Ind rec =>
    fields.splay-over-positive x L {{ fun x => lp:Fields_t x -> lp:Fields_t x -> bool }}
      {{ fun _ _ => true }}
      do-fields
      (R rec x).  
pred do-fields i:term, o:term.
do-fields Ty {{ fun a b => lp:(R a b) }} :-
  @pi-decl `x` _ x\
  @pi-decl `y` _ y\
  do-fields.aux Ty x y (R x y).

do-fields.aux (prod N T F) P1 P2 {{ lp:X && lp:R }} :- F = (x\prod _ _ _), !, % not the last one
  eqb-for T EQB,
  coq.mk-app EQB [{{ fst lp:P1 }}, {{ fst lp:P2 }}] X,
  do-fields.aux (F {{ unit }}) {{ snd lp:P1 }} {{ snd lp:P2 }} R.

do-fields.aux (prod N T _) P1 P2 X :-
  eqb-for T EQB,
  coq.mk-app EQB [P1, P2] X.

do-fields.aux _ _ _ {{ true }}.

}